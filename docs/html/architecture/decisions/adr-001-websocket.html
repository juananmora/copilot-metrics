<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADR 001: WebSocket vs Polling para Tiempo Real</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #64748b;
            --background-color: #ffffff;
            --surface-color: #f8fafc;
            --text-color: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --code-bg: #f1f5f9;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.7;
            color: var(--text-color);
            background-color: var(--background-color);
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .nav-breadcrumb {
            margin-bottom: 2rem;
            padding: 1rem;
            background: var(--surface-color);
            border-radius: 8px;
            font-size: 0.875rem;
        }
        
        .nav-breadcrumb a {
            color: var(--primary-color);
            text-decoration: none;
        }
        
        .nav-breadcrumb a:hover { text-decoration: underline; }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.3;
        }
        
        h1 {
            font-size: 2.5rem;
            color: var(--primary-color);
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }
        
        h2 {
            font-size: 1.875rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        
        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.25rem; color: var(--secondary-color); }
        
        p { margin-bottom: 1rem; }
        
        a { color: var(--primary-color); text-decoration: none; }
        a:hover { text-decoration: underline; }
        
        ul, ol { margin-bottom: 1rem; padding-left: 2rem; }
        li { margin-bottom: 0.5rem; }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            font-size: 0.9rem;
        }
        
        th, td {
            padding: 0.75rem 1rem;
            text-align: left;
            border: 1px solid var(--border-color);
        }
        
        th {
            background-color: var(--surface-color);
            font-weight: 600;
        }
        
        tr:nth-child(even) { background-color: var(--surface-color); }
        tr:hover { background-color: #f1f5f9; }
        
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.875rem;
            background-color: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
        }
        
        pre {
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1.5rem 0;
        }
        
        pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        .mermaid {
            background-color: var(--surface-color);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
            text-align: center;
        }
        
        blockquote {
            border-left: 4px solid var(--primary-color);
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background-color: var(--surface-color);
            border-radius: 0 8px 8px 0;
        }
        
        blockquote p:last-child { margin-bottom: 0; }
        
        hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 2rem 0;
        }
        
        img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 1rem 0;
        }
        
        .doc-footer {
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }
        
        @media (max-width: 768px) {
            body { padding: 1rem; }
            h1 { font-size: 1.875rem; }
            h2 { font-size: 1.5rem; }
            table { display: block; overflow-x: auto; }
        }
        
        @media print {
            body { max-width: none; padding: 0; }
            .nav-breadcrumb { display: none; }
            pre { white-space: pre-wrap; }
        }
    </style>
</head>
<body>
    <nav class="nav-breadcrumb"><a href="index.html">Inicio</a> / <a href="../../index.html">architecture</a> / <a href="../index.html">decisions</a> / <span>adr-001-websocket</span></nav>
    <article>
        <h1>ADR 001: WebSocket vs Polling para Tiempo Real</h1>
<p><strong>Estado</strong>: Aceptado
<strong>Fecha</strong>: 2026-02
<strong>Autores</strong>: Equipo de Desarrollo</p>
<h2>Contexto</h2>
<p>El Copilot Metrics Portal necesita mostrar datos actualizados de GitHub Copilot a los usuarios. Los datos cambian con frecuencia (nuevas PRs, cambios de estado, nuevos usuarios activos) y los usuarios esperan ver información reciente sin necesidad de refrescar manualmente la página.</p>
<p>Se evaluaron dos alternativas principales para mantener los datos sincronizados:</p>
<ol>
<li><strong>Polling</strong>: Llamadas HTTP periódicas desde el cliente</li>
<li><strong>WebSocket</strong>: Conexión persistente bidireccional</li>
</ol>
<h2>Decisión</h2>
<p>Se decidió implementar <strong>WebSocket</strong> como mecanismo principal de comunicación en tiempo real, con REST API como fallback.</p>
<h2>Alternativas Consideradas</h2>
<h3>Alternativa 1: Polling HTTP</h3>
<p><strong>Descripción</strong>: El frontend realiza llamadas GET periódicas (cada 30 segundos) al backend para obtener datos actualizados.</p>
<p><strong>Pros</strong>:</p>
<ul>
<li>Implementación simple</li>
<li>Compatible con cualquier infraestructura</li>
<li>Sin necesidad de mantener conexiones persistentes</li>
<li>Fácil de cachear con CDN</li>
</ul>
<p><strong>Contras</strong>:</p>
<ul>
<li>Ineficiente: muchas llamadas sin cambios reales</li>
<li>Latencia: hasta 30 segundos para ver actualizaciones</li>
<li>Mayor carga en servidor y red</li>
<li>No escala bien con muchos clientes</li>
</ul>
<h3>Alternativa 2: WebSocket (Elegida)</h3>
<p><strong>Descripción</strong>: Conexión persistente donde el servidor puede enviar actualizaciones instantáneamente cuando hay cambios.</p>
<p><strong>Pros</strong>:</p>
<ul>
<li>Actualizaciones instantáneas</li>
<li>Eficiente: solo envía cuando hay cambios</li>
<li>Menor latencia percibida</li>
<li>Permite comunicación bidireccional (refresh manual, ping/pong)</li>
<li>Mejor UX con indicadores de conexión en tiempo real</li>
</ul>
<p><strong>Contras</strong>:</p>
<ul>
<li>Más complejo de implementar</li>
<li>Requiere gestión de reconexiones</li>
<li>Necesita balanceo de carga sticky sessions</li>
<li>Mayor uso de memoria en servidor por conexiones activas</li>
</ul>
<h3>Alternativa 3: Server-Sent Events (SSE)</h3>
<p><strong>Descripción</strong>: Stream unidireccional del servidor al cliente.</p>
<p><strong>Pros</strong>:</p>
<ul>
<li>Más simple que WebSocket</li>
<li>Usa HTTP estándar</li>
<li>Reconexión automática del navegador</li>
</ul>
<p><strong>Contras</strong>:</p>
<ul>
<li>Solo unidireccional (servidor → cliente)</li>
<li>No permite refresh manual desde cliente</li>
<li>Menos soporte en herramientas de desarrollo</li>
</ul>
<h2>Justificación</h2>
<p>Se eligió WebSocket porque:</p>
<ol>
<li><p><strong>Bidireccionalidad necesaria</strong>: El usuario puede solicitar refresh manual, lo cual requiere enviar mensajes del cliente al servidor.</p>
</li>
<li><p><strong>Experiencia de usuario</strong>: Los datos de Copilot son valiosos y los usuarios esperan ver información actualizada. La latencia de polling degradaría la experiencia.</p>
</li>
<li><p><strong>Eficiencia</strong>: Con múltiples usuarios conectados, el modelo de broadcast de WebSocket es más eficiente que cada cliente haciendo polling.</p>
</li>
<li><p><strong>Escalabilidad futura</strong>: WebSocket permite implementar features como notificaciones, alertas, y colaboración en tiempo real.</p>
</li>
<li><p><strong>Indicadores de estado</strong>: WebSocket permite mostrar estado de conexión, clientes conectados, y timestamps de última actualización de forma nativa.</p>
</li>
</ol>
<h2>Consecuencias</h2>
<h3>Positivas</h3>
<ul>
<li>Usuarios ven actualizaciones en tiempo real</li>
<li>Menor carga de red agregada</li>
<li>Mejor UX con indicadores de conexión</li>
<li>Capacidad de broadcast a múltiples clientes</li>
<li>Base para futuras features en tiempo real</li>
</ul>
<h3>Negativas</h3>
<ul>
<li>Mayor complejidad en backend (gestión de conexiones)</li>
<li>Necesidad de implementar reconexión en frontend</li>
<li>Logs y debugging más complejos</li>
<li>Requiere WebSocket-capable infrastructure</li>
</ul>
<h3>Riesgos</h3>
<ul>
<li><strong>Desconexiones</strong>: Mitigado con lógica de reconexión automática y fallback a REST</li>
<li><strong>Memoria en servidor</strong>: Mitigado con límite de clientes y cleanup de conexiones inactivas</li>
<li><strong>Compatibilidad</strong>: Mitigado con REST API como fallback</li>
</ul>
<h2>Referencias</h2>
<ul>
<li><a href="https://tools.ietf.org/html/rfc6455">RFC 6455 - The WebSocket Protocol</a></li>
<li><a href="https://www.npmjs.com/package/ws">ws npm package</a></li>
<li><a href="https://tanstack.com/query/latest">React Query WebSocket Integration</a></li>
</ul>

    </article>
    <footer class="doc-footer">
        <p>Documentación generada automáticamente el 04/02/2026, 10:02</p>
    </footer>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'neutral',
            securityLevel: 'loose',
            flowchart: { useMaxWidth: true, htmlLabels: true }
        });
    </script>
</body>
</html>